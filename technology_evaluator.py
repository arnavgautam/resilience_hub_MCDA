from math import ceil
import numpy as np
from pandas import DataFrame
import pareto

from constant import CO2_INTENSITY, DIESEL_POWER_OUTPUT, FIXED_COSTS, NOX_AIR_POLLUTANT_INTENSITY, PM_AIR_POLLUTANT_INTENSITY, SO2_AIR_POLLUTANT_INTENSITY, PVWATTS_HOURLY_8760, SOFC_POWER_OUTPUT, STORAGE_ENERGY_CAPACITY, STORAGE_MAX_DISCHARGE_RATE, TECH_LABELS, VARIABLE_COSTS, Technology, STORAGE_ENERGY_CAPACITY, STORAGE_MAX_DISCHARGE_RATE, TECH_LABELS, VARIABLE_COSTS, Technology

class TechnologyEvaluator():

    def __init__(self, categories = ['Economic Cost', 'CO2 Pollution', 'NOx Air Pollution', 'PM Air Pollution', 'SO2 Air Pollution']):
        self.categories = categories
        self.tech_criteria_data = DataFrame(columns = self.categories)

    def compile_solar_output(self, start, end):
        self.SOLAR_OUTPUT = PVWATTS_HOURLY_8760["AC System Output (W)"][start:end]
        # For solar + storage, we assume that max output is the battery discharging at max rate and the solar panel also sending its power to the grid
        self.SOLAR_STORAGE_POWER_OUTPUT = max(self.SOLAR_OUTPUT) + STORAGE_MAX_DISCHARGE_RATE
        # For solar + storage, we assume that the total energy is the energy generated by the solar panel, plus the full capacity of the battery
        self.SOLAR_STORAGE_ENERGY_OUTPUT = sum(self.SOLAR_OUTPUT) + STORAGE_ENERGY_CAPACITY
        
        self.POWER_OUTPUTS = {Technology.SOLAR_STORAGE:self.SOLAR_STORAGE_POWER_OUTPUT, Technology.SOFC:SOFC_POWER_OUTPUT, Technology.DIESEL: DIESEL_POWER_OUTPUT}

    def gather_tech_performance(self, tech, number_of_systems, total_kW_gen):
        fixed_cost = number_of_systems * FIXED_COSTS[tech]
        variable_cost = total_kW_gen * VARIABLE_COSTS[tech]
        co2_emissions = total_kW_gen * CO2_INTENSITY[tech]
        NOx_air_pollutant_emissions = total_kW_gen * NOX_AIR_POLLUTANT_INTENSITY[tech]
        PM_air_pollutant_emissions = total_kW_gen * PM_AIR_POLLUTANT_INTENSITY[tech]
        SO2_air_pollutant_emissions = total_kW_gen * SO2_AIR_POLLUTANT_INTENSITY[tech]
        # social_benefit = total_kWh
        tech_data = [fixed_cost + variable_cost, co2_emissions, NOx_air_pollutant_emissions, PM_air_pollutant_emissions, SO2_air_pollutant_emissions]#, social_benefit]
        return tech_data
    
    def enumerate_and_evaluate_technologies(self, kW_gen_data):
        total_kW_gen = sum(kW_gen_data)

        # First determine how single-technologies setups would fare
        for tech in Technology:
            number_of_systems = ceil(max(kW_gen_data) / self.POWER_OUTPUTS[tech])
            if tech is Technology.SOLAR_STORAGE and number_of_systems*self.SOLAR_STORAGE_POWER_OUTPUT < total_kW_gen:
                # If peak solar generation is enough but overall energy generation is not enough
                number_of_systems = max(number_of_systems, ceil(total_kW_gen / self.SOLAR_STORAGE_ENERGY_OUTPUT))

            tech_data = self.gather_tech_performance(tech, number_of_systems, total_kW_gen)

            self.tech_criteria_data.loc[f'{number_of_systems} {TECH_LABELS[tech]}' + ('s' if number_of_systems > 1 else '')] = tech_data
                

        # Next, determine how two-technology setups would fare. One main technology, one for additional generation needed
        for tech in Technology:
            tech1, tech2 = [option for option in Technology if option is not tech]

            # Tech1 as main generating option
            tech1_number_of_systems = max(kW_gen_data) // self.POWER_OUTPUTS[tech1]

            if tech1_number_of_systems == 0:
                continue

            tech1_kW_gen_data = np.copy(kW_gen_data)
            if tech1 is Technology.SOLAR_STORAGE:
                # Power output always stays under possible generation (depending on solar production in that hour)
                tech1_kW_gen_data = np.minimum(tech1_kW_gen_data, tech1_number_of_systems*self.SOLAR_OUTPUT)
                if tech1_number_of_systems*self.SOLAR_STORAGE_ENERGY_OUTPUT < sum(tech1_kW_gen_data):
                    # If peak solar generation is enough but overall energy generation is not enough
                    tech1_number_of_systems = max(tech1_number_of_systems, ceil(sum(tech1_kW_gen_data) / self.SOLAR_STORAGE_ENERGY_OUTPUT))
            else:
                # Power output always stays under possible generation (not time-dependent)
                tech1_kW_gen_data[tech1_kW_gen_data > tech1_number_of_systems*self.POWER_OUTPUTS[tech1]] = tech1_number_of_systems*self.POWER_OUTPUTS[tech1]

            tech2_kW_gen_data = kW_gen_data - tech1_kW_gen_data
            tech2_number_of_systems = ceil(max(tech2_kW_gen_data) / self.POWER_OUTPUTS[tech2])

            if tech2_number_of_systems == 0:
                continue

            tech1_data = self.gather_tech_performance(tech1, tech1_number_of_systems, sum(tech1_kW_gen_data))
            tech2_data = self.gather_tech_performance(tech2, tech2_number_of_systems, sum(tech2_kW_gen_data))
            combined_data = np.add(tech1_data, tech2_data)

            self.tech_criteria_data.loc[f'{tech1_number_of_systems} {TECH_LABELS[tech1]}' + ('s' if tech1_number_of_systems > 1 else '') + ' & ' +
                f'{tech2_number_of_systems} {TECH_LABELS[tech2]}' + ('s' if tech2_number_of_systems > 1 else '')] = combined_data
    
    def find_non_dominated_options(self):
        self.non_dominated_options = pareto.eps_sort([list(self.tech_criteria_data.itertuples())], list(self.tech_criteria_data.columns.map(self.tech_criteria_data.columns.get_loc).values + 1))
        column_list = ["Name", *self.tech_criteria_data.columns.values]
        # convert multi-dimension array to DataFrame
        self.non_dominated_options = DataFrame.from_records(self.non_dominated_options, columns=column_list, index="Name")
        