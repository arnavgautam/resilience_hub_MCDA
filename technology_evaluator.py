from math import ceil
from pathlib import Path
import numpy as np
from pandas import concat, DataFrame
import pareto

import time
from constant import CO2_INTENSITY, CRITERIA, DIESEL_POWER_OUTPUT, FIXED_COSTS, NOX_AIR_POLLUTANT_INTENSITY, PM_AIR_POLLUTANT_INTENSITY, SO2_AIR_POLLUTANT_INTENSITY, PVWATTS_HOURLY_8760, SOFC_POWER_OUTPUT, STORAGE_ENERGY_CAPACITY, STORAGE_MAX_DISCHARGE_RATE, TECH_LABELS, VARIABLE_COSTS, Technology, STORAGE_ENERGY_CAPACITY, STORAGE_MAX_DISCHARGE_RATE, TECH_LABELS, VARIABLE_COSTS, Technology

class TechnologyEvaluator():

    def __init__(self, categories = CRITERIA, CNSP_THRESHOLD = 0.2):
        self.categories = categories
        self.CNSP_THRESHOLD = CNSP_THRESHOLD
        self.tech_criteria_data = DataFrame(columns = self.categories)
        self.CNSP_failing_tech_criteria_data = DataFrame(columns = self.categories)
        self.tech_output_timeseries = dict()

    def compile_tech_outputs(self, start, end):
        self.tech_output_timeseries[Technology.SOFC] = [10000] * (end - start)
        self.tech_output_timeseries[Technology.DIESEL] = [10000] * (end - start)
        self.tech_output_timeseries[Technology.SOLAR_STORAGE] = PVWATTS_HOURLY_8760["AC System Output (W)"][start:end].tolist() # Battery behavior is modeled separately


        # For solar + storage, we assume that max output is the battery discharging at max rate and the solar panel also sending its power to the grid
        # self.SOLAR_STORAGE_POWER_OUTPUT = max(self.SOLAR_OUTPUT) + STORAGE_MAX_DISCHARGE_RATE
        # For solar + storage, we assume that the total energy is the energy generated by the solar panel, plus the full capacity of the battery
        # self.SOLAR_STORAGE_ENERGY_OUTPUT = sum(self.SOLAR_OUTPUT) + STORAGE_ENERGY_CAPACITY
        
        # self.POWER_OUTPUTS = {Technology.SOLAR_STORAGE:self.SOLAR_STORAGE_POWER_OUTPUT, Technology.SOFC:SOFC_POWER_OUTPUT, Technology.DIESEL: DIESEL_POWER_OUTPUT}

    def gather_tech_performance(self, tech, number_of_systems, tech_kW_gen, system_total_output):
        fixed_cost = number_of_systems * FIXED_COSTS[tech]
        variable_cost = tech_kW_gen * VARIABLE_COSTS[tech]
        c_econ = (fixed_cost + variable_cost)/system_total_output
        co2_emissions = (tech_kW_gen * CO2_INTENSITY[tech]) / system_total_output
        NOx_air_pollutant_emissions = (tech_kW_gen * NOX_AIR_POLLUTANT_INTENSITY[tech]) / system_total_output
        PM_air_pollutant_emissions = (tech_kW_gen * PM_AIR_POLLUTANT_INTENSITY[tech]) / system_total_output
        SO2_air_pollutant_emissions = (tech_kW_gen * SO2_AIR_POLLUTANT_INTENSITY[tech]) / system_total_output
        tech_data = [c_econ, co2_emissions, NOx_air_pollutant_emissions, PM_air_pollutant_emissions, SO2_air_pollutant_emissions]
        return np.array(tech_data)
    
    def evaluate_technologies(self, kW_gen_data, hourly_loads, EWOMP_factors, technology_sets, gamma):
        evaluation_start_time = time.perf_counter()
        CNSP_failing_systems = list()
        for tech_set in technology_sets:
            individual_tech_outputs = dict()
            system_output = self.get_system_output_timeseries(tech_set, kW_gen_data, individual_tech_outputs)
            
            customer_not_supplied_probability = self.get_customer_not_supplied_probability(system_output, kW_gen_data)
            combined_data = None
            for tech, tech_number_of_systems in tech_set.items():
                tech_data = self.gather_tech_performance(tech, tech_number_of_systems, sum(individual_tech_outputs[tech]), sum(system_output))
                if combined_data is None:
                    combined_data = tech_data
                else:
                    combined_data = np.add(combined_data, tech_data)
            
            EWOMP = self.get_EWOMP(system_output, kW_gen_data, hourly_loads, EWOMP_factors, gamma)
            combined_data = np.append(combined_data, customer_not_supplied_probability)
            combined_data = np.append(combined_data, -EWOMP)

            system_label = ' & '.join([f'{tech_set[tech]} {TECH_LABELS[tech]}' + ('s' if False and tech_set[tech] > 1 else '') for tech in tech_set])
            
            if customer_not_supplied_probability > self.CNSP_THRESHOLD:
                CNSP_failing_systems.append(tech_set)
                self.CNSP_failing_tech_criteria_data.loc[system_label] = combined_data
                continue

            self.tech_criteria_data.loc[system_label] = combined_data
        
        print(f"Evaluation took {time.perf_counter() - evaluation_start_time} seconds")
        return CNSP_failing_systems

    def get_system_output_timeseries(self, tech_set, kW_gen_data, individual_tech_outputs):
        system_output = np.zeros(len(kW_gen_data))
        for tech in tech_set:
            individual_tech_outputs[tech] = np.multiply(self.tech_output_timeseries[tech], tech_set[tech])
            system_output += individual_tech_outputs[tech]

        # Adjust battery behavior as possible and as needed
        if tech_set[Technology.SOLAR_STORAGE] > 0:
            max_charge_rate = STORAGE_MAX_DISCHARGE_RATE * tech_set[Technology.SOLAR_STORAGE]
            starting_energy_stored = STORAGE_ENERGY_CAPACITY * tech_set[Technology.SOLAR_STORAGE]
            cumulative_energy = starting_energy_stored
            for i in range(len(kW_gen_data)):
                present_generation = system_output[i]
                needed_generation = kW_gen_data[i]
                if needed_generation > present_generation and cumulative_energy > 0:
                    storage_outflow = min(needed_generation - present_generation, max_charge_rate, cumulative_energy)
                    cumulative_energy -= storage_outflow
                    system_output[i] += storage_outflow
                elif present_generation > needed_generation and cumulative_energy < starting_energy_stored:
                    storage_inflow = min(present_generation - needed_generation, max_charge_rate)
                    cumulative_energy = min(starting_energy_stored, cumulative_energy + storage_inflow)
                    system_output[i] -= storage_inflow

        return system_output
        
    def get_customer_not_supplied_probability(self, tech_output, kW_gen_data):
        # Check Loss of Load Probability for this tech set
        lost_load_hours = np.sum(tech_output < kW_gen_data)
        customer_not_supplied_probability = lost_load_hours / len(kW_gen_data)
        return customer_not_supplied_probability
    
    def get_EWOMP(self, system_output, kW_gen_data, hourly_loads, EWOMP_factors, gamma):
        # T_l^t is just hourly_loads
        # Create psi
        unsuccessful_hours = np.where(system_output < kW_gen_data)[0]
        psi = hourly_loads.copy()
        for hour in unsuccessful_hours:
            psi[hour].values[:] = 0
        # Calculate log(gamma*psi+1)
        delivered_value = psi.applymap(lambda x: np.log10(gamma*abs(x) + 1)).sum(axis=1)
        # Calculate log(gamma*T_l^t+1)
        demanded_value = hourly_loads.applymap(lambda x: np.log10(gamma*abs(x) + 1)).sum(axis=1)
        # Calculate sum of ratio
        value_ratios = delivered_value.divide(demanded_value)
        # Multiply by EWOMP_factor/d
        EWOMP_per_load = value_ratios.multiply(EWOMP_factors["EWOMP_factor"], fill_value=0) / len(system_output)
        # Take the mean of this DataFrame column (equivalent to summing all these and dividing by ||L_RH||)
        c_EWOMP = EWOMP_per_load.mean()
        # Return
        return c_EWOMP
    
    def find_non_dominated_options(self):
        if len(self.tech_criteria_data) == 0:
            self.non_dominated_options = self.tech_criteria_data
            return
        self.non_dominated_options = pareto.eps_sort([list(self.tech_criteria_data.itertuples())], list(self.tech_criteria_data.columns.map(self.tech_criteria_data.columns.get_loc).values + 1))
        column_list = ["Name", *self.tech_criteria_data.columns.values]
        # convert multi-dimension array to DataFrame
        self.non_dominated_options = DataFrame.from_records(self.non_dominated_options, columns=column_list, index="Name")
    
    def save(self, filepath):
        Path(filepath).parent.mkdir(parents=True, exist_ok=True)
        all_option_filepath = Path(filepath + "_all.csv")
        self.tech_criteria_data.to_csv(all_option_filepath)
        nd_option_filepath = Path(filepath + "_nd.csv")
        self.non_dominated_options.to_csv(nd_option_filepath)
        generated_option_filepath = Path(filepath + "_generated.csv")
        generated_data = concat([self.tech_criteria_data, self.CNSP_failing_tech_criteria_data])
        generated_data.to_csv(generated_option_filepath)

        